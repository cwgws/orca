"""
Model for tracking search results and megadocs produced by the ORCA system.

This module defines the `Search` class and its associated methods for storing
and managing searches, their progress, and the artifacts produced as intended
output by ORCA.
"""

import logging
from pathlib import Path
from typing import Self

from slugify import slugify
from sqlalchemy import Column, ForeignKey, String, Table
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship

from orca import config
from orca.helpers import dt_now

from .base import Base, StatusMixin
from .corpus import Corpus
from .db import save, with_async_session
from .document import Document

log = logging.getLogger(__name__)


_search_documents = Table(
    "search_documents",
    Base.metadata,
    Column("search_guid", ForeignKey("searches.guid")),
    Column("document_guid", ForeignKey("documents.guid")),
)
"""Many-to-many relationship table holding search results.
"""


class Search(Base, StatusMixin):
    """Represents a search operation within the ORCA system.

    This class stores information about a search, including the search string,
    associated `Corpus`, `Document`s, and `Megadoc`s. It also provides methods
    for creating a `Search`, adding documents to a `Search`, and generating
    `Megadoc`s based on results.

    Attributes:
        search_str (str): The string used to query the documents.
        corpus_guid (str, hidden): The unique identifier of the associated
            `Corpus`. We provide a reference to the `Corpus` directly, so this
            is hidden from the `init()`.
        corpus (Corpus): The `Corpus` instance related to this search.
        documents (list[Document], optional): List of `Document`s found by the
            `Search`.
        document_count (int, optional): The total number of documents found by
            the `Search`.
        megadocs (list[Megadoc], optional): List of `Megadoc`s generated by the
            `Search`.
    """

    search_str: Mapped[str] = mapped_column(String(255))
    corpus_guid: Mapped[str] = mapped_column(
        String(22), ForeignKey("corpuses.guid"), init=False
    )
    corpus: Mapped[Corpus] = relationship(lazy="selectin")
    documents: Mapped[list[Document]] = relationship(
        init=False, default_factory=list, secondary=_search_documents, lazy="selectin"
    )
    document_count: Mapped[int] = mapped_column(init=False, insert_default=0)
    megadocs: Mapped[list["Megadoc"]] = relationship(
        init=False, default_factory=list, cascade="all, delete-orphan", lazy="subquery"
    )

    @with_async_session
    async def add_document(self, document: Document, *, session: AsyncSession) -> None:
        """Adds a `Document` instance to this `Search`'s results.

        This method appends the provided document to the list of documents
        associated with the search, updates the document count, and persists
        the change in the database.

        Args:
            document (Document): The `Document` instance to add to the search
                results.
            session (AsyncSession, optional): An active asynchronous database
                session. If not provided, the method will create and manage its
                own session.
        """
        log.debug("âœ¨ Adding Document <%s> to Search <%s>", document.guid, self.guid)
        await session.refresh(self, ["documents"])

        if document in self.documents:
            log.warning(
                "ðŸš§ Tried adding duplicate Document <%s> to Search <%s>",
                document.guid,
                self.guid,
            )
            return

        self.documents.append(document)
        self.document_count += 1
        await save(self, session=session)

    @with_async_session
    async def add_megadoc(
        self, filetype: str, *, immediate: bool = True, session: AsyncSession
    ) -> "Megadoc":
        """Creates and associates a `Megadoc` with this `Search`.

        This method generates a new `Megadoc` based on the specified filetype,
        associates it with the current search, and saves it to the database. If
        a `Megadoc` of the specified filetype already exists for this `Search`,
        returns that instance instead.

        Args:
            filetype (str): The filetype of the megadoc to be created, preceded
                by "." (e.g., `.TXT`, `.DOCX`)
            immediate (bool, optional): If `True`, the session is committed
                after saving the `Megadoc`. Default is `True`.
            session (AsyncSession, optional): An active asynchronous database
                session. If not provided, the method will create and manage its
                own session.

        Returns:
            The newly created `Megadoc` instance, or the extant `Megadoc` with
                this same filetype.
        """
        log.debug("âœ¨ Adding Megadoc of type '%s' to Search <%s>", filetype, self.guid)
        for megadoc in self.megadocs:
            if megadoc.filetype.lower() == filetype.lower():
                log.warning(
                    "ðŸš§ Tried adding Megadoc of duplicate type '%s' to Search <%s>",
                    filetype,
                    self.guid,
                )
                return megadoc

        megadoc = await Megadoc.create(
            self.guid, filetype, immediate=immediate, session=session
        )
        self.megadocs.append(megadoc)
        await save(self, immediate=immediate, session=session)
        return megadoc


class Megadoc(Base, StatusMixin):
    """Metadata for a file containing `Search` results.

    The `Megadoc` class is a SQLAlchemy model that represents a megadoc file
    in the database. It includes attributes for the file type, paths, and URL,
    as well as methods for creating new megadoc entries in the database.

    Attributes:
        search_guid (str): The unique identifier of the associated `Search`.
        filetype (str): The type of file, e.g., ".txt" or ".docx".
        filename (str, optional): The name of the file.
        path (str, optional): The **relative** path to the file within the
            data directory
        url (str, optional): The public URL where the file can be accessed.
    """

    search_guid: Mapped[str] = mapped_column(String(22), ForeignKey("searches.guid"))
    filetype: Mapped[str] = mapped_column(String(12))
    filename: Mapped[str] = mapped_column(String(255), default="")
    path: Mapped[str] = mapped_column(String(255), default="")
    url: Mapped[str] = mapped_column(String(255), default="")
    progress: Mapped[float] = mapped_column(init=False, insert_default=0.0)

    @classmethod
    @with_async_session
    async def create(
        cls,
        search_guid: str,
        filetype: str,
        *,
        megadoc_path: Path = config.megadoc_path,
        immediate: bool = True,
        session: AsyncSession,
    ) -> Self:
        """Create a new `Megadoc` record in the database.

        This class method creates a new `Megadoc` entry in the database,
        generating a unique filename based on the search string and current
        timestamp. It also sets the paths and URL for the file using the
        provided or default path factory.

        Args:
            search_guid (str): The search associated with this megadoc.
            filetype (str): The file type, including preceding "." (e.g.,
                ".txt", ".docx").
            data_path (Path, optional): **Relative** path where megadoc files
                are stored. This is usually provided by `config.megadoc_path`
                but can be overridden here for edge cases or testing.
            immediate (bool, optional): If `True`, the session is committed
                after saving the `Megadoc`. Default is `True`.
            session (AsyncSession, optional): An active asynchronous database
                session. If not provided, the method will create and manage its
                own session.

        Returns:
            The created `Megadoc` instance.
        """
        search = await Search.get(search_guid, session=session)
        filename = (
            f"{slugify(search.search_str)}"
            f"_{dt_now().strftime('%Y%m%d-%H%M%SZ')}"
            f"{filetype}"
        ).lower()
        return await super().create(
            search_guid,
            filetype,
            filename=filename,
            path=str(megadoc_path / filename),
            url=f"{config.s3.url}/{megadoc_path}/{filename}",
            immediate=immediate,
            session=session,
        )
